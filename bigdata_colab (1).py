# -*- coding: utf-8 -*-
"""bigdata_colab.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yyUvFMgHV6am7Pq3Vezlos6QJ37LFrCr
"""

!ls -al ./

from google.colab import files
uploades = files.upload()

!ls -al ./

if not tpu:
  import tensorflow as tf
  # Detect hardware, return appropriate distribution strategy
  try:
      tpu = tf.distribute.cluster_resolver.TPUClusterResolver()  # TPU detection. No parameters necessary if TPU_NAME environment variable is set. On Kaggle this is always the case.
      print('Running on TPU ', tpu.master())
  except ValueError:
      tpu = False

  if tpu:
      tf.config.experimental_connect_to_cluster(tpu)
      tf.tpu.experimental.initialize_tpu_system(tpu)
      #strategy = tf.distribute.experimental.TPUStrategy(tpu)
      strategy = tf.distribute.TPUStrategy(tpu)
      
  else:
      strategy = tf.distribute.get_strategy() # default distribution strategy in Tensorflow. Works on CPU and single GPU.

  print("REPLICAS: ", strategy.num_replicas_in_sync)
  print(tpu)

"""# New Section"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import pandas as pd
import numpy as np 
import seaborn as sns
import matplotlib.pyplot as plt
# %matplotlib inline

"""# Load data"""

# Global Data 
startDate='1950-1-1'
endDate=  '2014-1-1'

#fileName='EgTemp1.csv' ; Tit='Egypt'; Cols=['dt','AverageTemperature']
fileName='canTemp.csv' ; Tit='Canada';Cols=['Dt','Tmp']

#tpu=False
# Load
df= pd.read_csv('./'+fileName)
print(df.columns)
print(df.shape)
df.head()
df.columns

print(df.describe())
print(df.shape)
data=df.copy()
if len(data[data.isna().any(axis=1)])!=0:
    print('--->>Drop Nans')
    print(data[data.isna().any(axis=1)])
data=data.dropna()


data[Cols[0]] = pd.to_datetime(data[Cols[0]])
mask = (data[Cols[0]] >= startDate) & (data[Cols[0]] <= endDate)
data=data.loc[mask]
data = pd.DataFrame(list(data[Cols[1]]), index=data[Cols[0]],columns=['temp'])
print(data.describe())
data

plt.figure(figsize=(25, 7))
plt.plot(data, linewidth=1)
# plt.grid()
plt.title("1/2 CenturyTime Series (temperature in {})".format(Tit),fontsize=20)
plt.show()

"""# Scale / resumeScace"""

def resScale(df,tMin,tMax):
    d=df * (tMax-tMin)+tMin
    return d
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range=(0, 1))
tMin,tMean,tMax=(data['temp'].min(),data['temp'].mean(),data['temp'].max())
print('Min Mean Max',tMin,tMean,tMax)
data_scaled = scaler.fit_transform(data)
#d=resScale(data_scaled,tMin,tMax)
#d

steps= 120 #Input Blocks
inp = []
out = []
for i in range(len(data_scaled) - (steps)):
    inp.append(data_scaled[i:i+steps])
    out.append(data_scaled[i+steps])
inp= np.asanyarray(inp)
out= np.asanyarray(out)
trainRatio=0.80
trainSize=int(trainRatio*len(data))
x_train = inp[:trainSize,:,:]
x_test = inp[trainSize:,:,:]    
y_train = out[:trainSize]    
y_test= out[trainSize:]
print('I/O',inp.shape,out.shape)
print('Train/test',x_train.shape,x_test.shape)

import matplotlib.pyplot as plt
import seaborn as sns
from tensorflow.keras.layers import Dense,RepeatVector, LSTM, Dropout
from tensorflow.keras.layers import Flatten, Conv1D, MaxPooling1D
from tensorflow.keras.layers import Bidirectional, Dropout
from tensorflow.keras.models import Sequential
from tensorflow.keras.utils import plot_model

if tpu:
    import tensorflow as tf
    # detect and init the TPU
    #tpu = tf.distribute.cluster_resolver.TPUClusterResolver.connect()
    # instantiate a distribution strategy
    #tpu_strategy = tf.distribute.experimental.TPUStrategy(tpu)
    tpu_strategy = tf.distribute.TPUStrategy(tpu)

    # instantiating the model in the strategy scope creates the model on the TPU
    with tpu_strategy.scope():
        model = Sequential()
        model.add(LSTM(50, return_sequences= True, input_shape= (steps,1)))
        model.add(LSTM(50, return_sequences=True))
        model.add(LSTM(50))
        model.add(Dense(1))
        model.compile(loss = 'mean_squared_error', optimizer = 'adam')
else:
    model = Sequential()
    model.add(LSTM(50, return_sequences= True, input_shape= (steps,1)))
    model.add(LSTM(50, return_sequences=True))
    model.add(LSTM(50))
    model.add(Dense(1))
    model.compile(loss = 'mean_squared_error', optimizer = 'adam')

import time
start = time.time()
model.fit(x_train,y_train,epochs=100, verbose=1, )
end = time.time()
print(end - start)

x_test

print("Predicted Value",model.predict(x_train)[4][0])
print("Expected value",y_train[4][0])
predictions=model.predict(x_test)
#print(predictions[:5])
pred_df=pd.DataFrame(predictions,columns=['Pred'])
#print(pred_df[:5])
pred_df['TrueValues']=y_test
print(pred_df[:5])

plt.figure(figsize=(12,8))
sns.lineplot(data= pred_df)
plt.title("Predictions VS True Values on Scaled Testing Set {}".format(Tit))

predDfResScale=pred_df.copy()
predDfResScale['Pred']=resScale(pred_df['Pred'],tMin,tMax)
predDfResScale['TrueValues']=resScale(y_test,tMin,tMax)
plt.figure(figsize=(12,8))
sns.lineplot(data= predDfResScale)
plt.title("Predictions VS True Values on Testing Set ({})".format(Tit))
plt.show()

#print(x_test.shape)
#xx=x_test[-1]
#print(xx.shape)
#xx=np.reshape(xx, (1,24,1))
#p=model.predict(xx)

"""# Generate N"""

N=12*10 # more 10 years
from datetime import timedelta
def generateOne(model,list_24):
    inp=np.reshape(list_24, (1,steps,1))
    p=model.predict(inp,verbose=False)
    list_24.append(np.array(p[0]))
    list_24=list_24[1:]
    return p,list_24
def generateN(model,list_24,N):
    out=[]
    for i in range(N):
        p,list_24=generateOne(model,list_24)
        out.append(p)
    return out
    
l_24=list(x_test[-1])
yNew=generateN(model,l_24,N)

ddd=data.copy()
last_date = ddd.iloc[[-1]].index
for i in range(N):
    last_date=last_date+ timedelta(days=30)
    ddd = ddd.append(pd.DataFrame(index=last_date))
    ddd['temp'][-1]=resScale(yNew[i],tMin,tMax)
    #print(yNew[i],resScale(yNew[i],tMin,tMax))

plt.figure(figsize=(12,8))
recs=ddd.shape[0]
#
plt.plot(ddd.index[0:recs-N],ddd['temp'][0:recs-N])
plt.plot(ddd.index[recs-N:],ddd['temp'][recs-N:])
plt.title("True Values+Prediction of N new monthes ({})".format(N,Tit))
#data.shape
plt.show()